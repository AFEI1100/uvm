
Section: TLM Interfaces, Ports, Exports and Transport Interfaces in TLM2.0
TLM, transaction-level modeling, is a modeling style for building highly 
abstract models of components and systems. It relies on transactions, objects
 that contain arbitrary, protocol-specific data to abstractly represent 
lower-level activity. In practice TLM refers to a family of abstraction levels 
beginning with cycle-accurate modeling, the most abstract, and extending 
upwards in abstraction as far as they eye can see. Cycle accurate, 
approximately timed, loosely timed, untimed, and token level are amongst 
the transaction-level abstractions commonly in use today.

The acronym TLM also refers to a system of code elements used to create
 transaction-level models. TLM-1 and TLM-2 are two TLM modeling systems
 which have been developed as industry standards for building 
transaction-level models. Both were built in SystemC and standardized
 within the TLM Working Group of the Open SystemC Initiative (OSCI). 
TLM-1 achieved standardization in 2005 and TLM-2 became a standard in 2009.
TLM-1 and TLM-2 share a common heritage and many of the same people who 
developed TLM-1 also worked on TLM-2. Otherwise, they are quite different 
things. TLM-1 is a message passing system. Interfaces are either untimed 
or rely on the target for timing. None of the interfaces provide for
 explicit timing annotations. TLM-2, while still enabling transfer of 
data and synchronization between independent processes, is mainly designed
 for high performance modeling of memory-mapped bus-based systems.

Sockets:

TLM 2.0 uses sockets to communicate between transaction
level elements. A similar set of methods is in UVM, which helps
lowering the learning curve for SystemC engineers. 
You can connect Sockects in UVM objects to fulfill necessary
communication completion models.

Sockets group together all the necessary core interfaces for
transportation and binding, allowing more generic usage models
than just TLM core interfaces.

A socket is like a port or export; in fact it is derived from the 
same base class as ports and export, namely uvm_port_base. 
However, unlike a port or export a socket provides both a 
forward and backward path. Thus you can enable asynchronous 
(pipelined) bi-directional communication by connecting sockets 
together. To enable this, a socket contains both a port and an export.
Components that initiate transactions are called initiators, 
and components that receive transactions sent by an initiator 
are called targets. Initiators have initiator sockets and targets have target
 sockets. Initiator sockets can connect to target sockets. You cannot connect
 initiator sockets to other initiator sockets and you cannot connect target 
sockets to target sockets.

TLM-2.0 provides the following two transport interfaces:

 Blocking (b_transport) - completes the entire transaction
within a single method call

 Non-blocking (nb_transport) - describes the progress of a
transaction using multiple nb_transport method calls going
back-and-forth between initiator and target

In general,any component might modify a transaction object during
its lifetime (subject to the rules of the protocol). Significant timing
points during the lifetime of a transaction (for example: start-ofresponse-
phase) are indicated by calling nb_transport in either
forward or backward direction, the specific timing point being given
by the phase argument.
Protocol-specific rules for reading or writing the attributes of a
transaction can be expressed relative to the phase. The phase can
be used for flow control, and for that reason might have a different
value at each hop taken by a transaction; the phase is not an
attribute of the transaction object.

A call to nb_transport always represents a phase transition.
However, the return from nb_transport might or might not do so,
the choice being indicated by the value returned from the function
(TLM_ACCEPTED versus TLM_UPDATED).
Generally, you indicate the completion of a transaction over a
particular hop using the value of the phase argument. As a shortcut,
a target might indicate the completion of the transaction by returning
a special value of TLM_COMPLETED. However, this is an option,
not a necessity.

The transaction object itself does not contain any timing information
by design. Or even events and status information concerning the
API. You can pass the delays as arguments to b_transport /
nb_transport and push the actual realization of any delay in the
simulator kernel downstream and defer (for simulation speed).

Use Models:
Since sockets are derived from uvm_port_base they are created and connected 
in the same way as port, and exports. Create them in the build phase and connect 
them in the connect phase by calling connect().
Initiator and target termination sockets are on the ends of any connection. 
There can be an arbitrary number of passthrough sockets in the path between 
initator and target.
Some socket types must be bound to imps  implementations of the transport 
tasks and functions. Blocking terminator sockets must be bound to an 
implementation of b_transport(), for example. Nonblocking initiator 
sockets must be bound to an implementation of nb_transport_bw and 
nonblocking target sockets must be bound to an implementation of 
nb_transport_fw. Typically, the task or function is implemented in the 
component in which the socket is instantiated and the component type and 
instance are provided to complete the binding.

Consider for example a consumer component with a blocking target socket.

Example:
| class consumer extends uvm_component;
|    tlm2_b_target_socket #(trans, consumer) target_socket;
|    function new(string name, uvm_component parent);
|      super.new(name, parent);
|    endfunction
|    function void build();
|      target_socket = new("target_socket", this, this);
|    endfunction
|    task b_transport(ref trans t, ref time delay);
|      #5;
|      uvm_report_info("consumer", t.convert2string());
|    endtask
| endclass
| 
The interface task b_transport is implemented in the consumer component. 
The consumer component type is used in the declaration of the target socket. 
This informs the socket object the type of the object that contains the 
interface task, in this case b_transport(). When the socket is instantiated 
"this" is passed in twice, once as the parent just like any other component 
instantiation and again to identify the object that holds the implementation 
of b_transport(). Finally, in order to complete the binding, an implementation 
of b_transport() must be present in the consumer component.
Any component that has either a blocking termination socket, a nonblocking
 initiator socket, or a nonblocking termination socket must provide 
implementations of the relevant components. This includes initiator and 
target components as well as interconnect components that have these kinds 
of sockets. Components with passthrough sockets do not need to provide 
implementations of any sort. Of course, they must ultimately be connected 
to sockets that do that the necessary implementations.

In summary:
 Call to b_transport - start-of-life of transaction
 Return from b_transport - end-of-life of transaction
 Phase argument to nb_transport - timing point within lifetime
of transaction
 Return value of nb_transport - whether return path is being
used (also shortcut to final phase)
 Response status within transaction object - protocol-specific
status, success/failure of transaction

On top of this, TLM-2.0 defines a generic payload and base protocol
to enhance interoperability for models with a memory-mapped bus
interface.

It is possible to use the interfaces described above with user-defined
transaction types and protocols for the sake of interoperability.
However, TLM-2.0 strongly recommends either using the base
protocol off-the-shelf or creating models of specific protocols on top
of the base protocol.


The UVM TLM library defines several abstract, transaction-level interfaces
and the ports and exports that facilitate their use.
Each TLM interface consists of one or more methods used to transport data,
typically whole transactions (objects) at a time. Component designs that
use TLM ports and exports to communicate are inherently more reusable,
interoperable, and modular.

Port and Export style interfaces:

The TLM standard specifies the required behavior (semantic) of each interface
method. Classes (components) that implement a TLM interface must meet the
specified semantic.

Each TLM interface is either blocking, non-blocking, or a combination of these
two.

blocking - A blocking interface conveys transactions in blocking fashion;
its methods do not return until the transaction has been successfully sent
or retrieved. Because delivery may consume time to complete, the methods
in such an interface are declared as tasks.

non-blocking - A non-blocking interface attempts to convey a transaction
without consuming simulation time. Its methods are declared as functions.
Because delivery may fail (e.g. the target component is busy and can not
accept the request), the methods may return with failed status. 

combination - A combination interface contains both the blocking and
non-blocking variants.  In SystemC, combination interfaces are defined
through multiple inheritance.  Because SystemVerilog does not support
multiple inheritance, the UVM emulates hierarchical interfaces via a
common base class and interface mask.

Like their SystemC counterparts, the UVM's TLM port and export implementations
allow connections between ports whose interfaces are not an exact match.
For example, an ~uvm_blocking_get_port~ can be connected to any port,
export or imp port that provides ~at the least~ an implementation
of the blocking_get interface, which includes the ~uvm_get_*~ ports and
exports, ~uvm_blocking_get_peek_*~ ports and exports, and
~uvm_get_peek_*~ ports and exports.

The sections below provide and overview of the unidirectional and
bidirectional TLM interfaces, ports, and exports.

Group: Generic Payload

Generic Payload transaction. This transaction represents a generic 
bus read/write access. It is used as the default transaction in
TLM2 blocking and nonblocking transport interfaces.

Group: Unidirectional Interfaces & Ports

The unidirectional TLM interfaces consist of blocking, non-blocking,
and combined blocking and non-blocking variants of the ~put~, ~get~ and ~peek~
interfaces, plus a non-blocking ~analysis~ interface.

Topic: Put

The ~put~ interfaces are used to send, or ~put~, transactions to other components.
Successful completion of a put guarantees its delivery, not execution.

(see uvm_ref_tlm_put_ifs.gif)

Topic: Get and Peek

The ~get~ interfaces are used to retrieve transactions from other components.
The ~peek~ interfaces are used for the same purpose, except the retrieved
transaction is not consumed; successive calls to ~peek~
will return the same object. Combined ~get_peek~ interfaces are also defined.

(see uvm_ref_tlm_get_peek_ifs.gif)

Topic: Analysis

The ~analysis~ interface is used to perform non-blocking broadcasts of
transactions to connected components.  It is typically used by
such components as monitors to publish transactions observed on a bus
to its subscribers, which are typically scoreboards and response/coverage
collectors. 

(see uvm_ref_tlm_analysis_if.gif)


Topic: Ports, Exports, and Imps

The UVM provides unidirectional ports, exports, and implementation ports
for connecting your components via the TLM interfaces.

Ports - instantiated in components that ~require~, or ~use~, the
associate interface to initiate transaction requests.

Exports - instantiated by components that ~forward~ an
implementation of the methods defined in the associated
interface. The implementation is typically provided by an
~imp~ port in a child component.

Imps - instantiated by components that ~provide~ or ~implement~
an implementation of the methods defined in the associated
interface.

(see uvm_ref_tlm_uni_ports.gif)

A summary of port, export, and imp declarations are

| class uvm_*_export #(type T=int)
|   extends uvm_port_base #(tlm_if_base #(T,T));
|
| class uvm_*_port #(type T=int)
|   extends uvm_port_base #(tlm_if_base #(T,T));
|
| class uvm_*_imp #(type T=int)
|   extends uvm_port_base #(tlm_if_base #(T,T));

where the asterisk can be any of

| blocking_put
| nonblocking_put
| put
|
| blocking_get
| nonblocking_get
| get
|
| blocking_peek
| nonblocking_peek
| peek
|
| blocking_get_peek
| nonblocking_get_peek
| get_peek
|
| analysis

Group: Bidirectional Interfaces & Ports

The bidirectional interfaces consist of blocking, non-blocking,
and combined blocking and non-blocking variants of the ~transport~,
~master~, and ~slave~ interfaces.

Bidirectional interfaces involve both a transaction request and
response.

Topic: Transport

The ~transport~ interface sends a request transaction and returns a
response transaction in a single task call, thereby enforcing an
in-order execution semantic. The request and response transactions
can be different types.

(see uvm_ref_tlm_transport_ifs.gif)

Topic: Master and Slave

The primitive, unidirectional ~put~, ~get~, and ~peek~ interfaces
are combined to form bidirectional master and slave interfaces.
The master puts requests and gets or peeks responses. The slave gets
or peeks requests and puts responses. Because the put and the get
come from different function interface methods, the requests and
responses are not coupled as they are with the ~transport~ interface.

(see uvm_ref_tlm_master_slave_ifs.gif)

Topic: Ports, Exports, and Imps

The UVM provides bidirectional ports, exports, and implementation ports
for connecting your components via the TLM interfaces.

Ports - instantiated in components that ~require~, or ~use~, the
associate interface to initiate transaction requests.

Exports - instantiated by components that ~forward~ an
implementation of the methods defined in the associated
interface. The implementation is typically provided by an
~imp~ port in a child component.

Imps - instantiated by components that ~provide~ or ~implement~
an implementation of the methods defined in the associated
interface.

(see uvm_ref_tlm_bidir_ports.gif)

A summary of port, export, and imp declarations are

| class uvm_*_port #(type REQ=int, RSP=int)
|   extends uvm_port_base #(tlm_if_base #(REQ, RSP));
|
| class uvm_*_export #(type REQ=int, RSP=int)
|   extends uvm_port_base #(tlm_if_base #(REQ, RSP));
|
| class uvm_*_imp #(type REQ=int, RSP=int)
|   extends uvm_port_base #(tlm_if_base #(REQ, RSP));

where the asterisk can be any of

| transport
| blocking_transport
| nonblocking_transport
|
| blocking_master
| nonblocking_master
| master
|
| blocking_slave
| nonblocking_slave
| slave

Group: Usage

This example illustrates basic TLM connectivity using
the blocking put inteface.

(see uvm_ref_tlm_hierarchy.gif)

port-to-port - leaf1's ~out~ port is connected to its parent's (comp1) ~out~ port

port-to-export - comp1's ~out~ port is connected to comp2's ~in~ export

export-to-export - comp2's ~in~ export is connected to its child's (subcomp2) ~in~ export

export-to-imp - subcomp2's ~in~ export is connected leaf2's ~in~ imp port.

imp-to-implementation - leaf2's ~in~ imp port is connected to its implementation, leaf2

Hierarchical port connections are resolved and optimized just before the 
<uvm_component::end_of_elaboration> phase. After optimization, calling
any port's interface method (e.g. leaf1.out.put(trans)) incurs a single
hop to get to the implementation (e.g. leaf2's put task), no matter how
far up and down the hierarchy the implementation resides.

| `include "uvm_pkg.sv"
| import uvm_pkg::*;
| 
| class trans extends uvm_transaction;
|   rand int addr;
|   rand int data;
|   rand bit write;
| endclass
| 
| class leaf1 extends uvm_component;
| 
|   `uvm_component_utils(leaf1)
| 
|   uvm_blocking_put_port #(trans) out;
| 
|   function new(string name, uvm_component parent=null);
|     super.new(name,parent);
|     out = new("out",this);
|   endfunction
| 
|   virtual task run();
|     trans t;
|     t = new;
|     t.randomize();
|     out.put(t);
|   endtask
| 
| endclass
| 
| 
| class comp1 extends uvm_component;
| 
|   `uvm_component_utils(comp1)
| 
|   uvm_blocking_put_port #(trans) out;
| 
|   leaf1 leaf;
| 
|   function new(string name, uvm_component parent=null);
|     super.new(name,parent);
|   endfunction
| 
|   virtual function void build();
|     out = new("out",this);
|     leaf = new("leaf1",this);
|   endfunction
| 
|   // connect port to port
|   virtual function void connect();
|     leaf.out.connect(out);
|   endfunction
| 
| endclass
| 
| 
| class leaf2 extends uvm_component;
| 
|   `uvm_component_utils(leaf2)
| 
|   uvm_blocking_put_imp #(trans,leaf2) in;
| 
|   function new(string name, uvm_component parent=null);
|     super.new(name,parent);
|     // connect imp to implementation (this)
|     in = new("in",this);
|   endfunction
| 
|   virtual task put(trans t);
|     $display("Got trans: addr=%0d, data=%0d, write=%0d",
|         t.addr, t.data, t.write);
|   endtask
| 
| endclass
| 
| 
| class subcomp2 extends uvm_component;
| 
|   `uvm_component_utils(subcomp2)
| 
|   uvm_blocking_put_export #(trans) in;
| 
|   leaf2 leaf;
| 
|   function new(string name, uvm_component parent=null);
|     super.new(name,parent);
|   endfunction
| 
|   virtual function void build();
|     in = new("in",this);
|     leaf = new("leaf2",this);
|   endfunction
| 
|   // connect export to imp
|   virtual function void connect();
|     in.connect(leaf.in);
|   endfunction
| 
| endclass
| 
| 
| class comp2 extends uvm_component;
| 
|   `uvm_component_utils(comp2)
| 
|   uvm_blocking_put_export #(trans) in;
| 
|   subcomp2 subcomp;
| 
|   function new(string name, uvm_component parent=null);
|     super.new(name,parent);
|   endfunction
| 
|   virtual function void build();
|     in = new("in",this);
|     subcomp = new("subcomp2",this);
|   endfunction
| 
|   // connect export to export
|   virtual function void connect();
|     in.connect(subcomp.in);
|   endfunction
| 
| endclass
| 
| 
| class env extends uvm_component;
| 
|   `uvm_component_utils(comp1)
| 
|   comp1 comp1_i;
|   comp2 comp2_i;
| 
|   function new(string name, uvm_component parent=null);
|     super.new(name,parent);
|   endfunction
| 
|   virtual function void build();
|     comp1_i = new("comp1",this);
|     comp2_i = new("comp2",this);
|   endfunction
| 
|   // connect port to export
|   virtual function void connect();
|     comp1_i.out.connect(comp2_i.in);
|   endfunction
| 
| endclass
| 
| 
| module top;
|   env e = new("env");
|   initial run_test();
|   initial #10 uvm_top.stop_request();
| endmodule
| 
