//
// -------------------------------------------------------------
//    Copyright 2004-2009 Synopsys, Inc.
//    Copyright 2010 Mentor Graphics Corp.
//    All Rights Reserved Worldwide
//
//    Licensed under the Apache License, Version 2.0 (the
//    "License"); you may not use this file except in
//    compliance with the License.  You may obtain a copy of
//    the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in
//    writing, software distributed under the License is
//    distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
//    CONDITIONS OF ANY KIND, either express or implied.  See
//    the License for the specific language governing
//    permissions and limitations under the License.
// -------------------------------------------------------------
//



//------------------------------------------------------------------------------
// CLASS: uvm_ral_block
// Block descriptor class derived from "uvm_ral_block". 
//------------------------------------------------------------------------------
virtual class uvm_ral_block extends uvm_object;

   local uvm_ral_block  parent;

   local static bit     m_roots[uvm_ral_block];
   local int unsigned   blks[uvm_ral_block];
   local int unsigned   regs[uvm_ral_reg];
   local int unsigned   vregs[uvm_ral_vreg];
   local int unsigned   mems[uvm_ral_mem];
   local bit            maps[uvm_ral_map];

   uvm_ral::path_e      default_path = uvm_ral::DEFAULT;
   uvm_ral_map          default_map;
   local string         default_hdl_path = "RTL";
   local uvm_ral_reg_backdoor backdoor;
   local uvm_object_string_pool #(uvm_queue #(string)) hdl_paths_pool;
   local string         root_hdl_paths[string];

   local bit            locked;

   local string         attributes[string];
   local string         constr[$];

   local int            has_cover;
   local int            cover_on;
   local string         fname = "";
   local int            lineno = 0;

   local static int id = 0;

   //----------------------
   // Group: Initialization
   //----------------------


   //------------------------------------------------------------------------------
   // FUNCTION: new
   // Creates an instance of a RAL model with the corresponding block as the top-level structural
   // element. The cover_on argument specifies the functional coverage models to be enabled
   // in the RAL model. Multiple functional coverage models may be specified by adding their
   // symbolic names. Only functional coverage models that were generated by ralgen using
   // the -c option can be enabled. Because the functional coverage models affect the memory
   // footprint and runtime performance of a RAL model, they should be enabled only when relevant.
   // It is not possible to enable a functional coverage model at a later time, but it is possible
   // to turn the measurement of a functional coverage model off then back on using the "uvm_ral_block::set_cover()"
   // method. 
   //------------------------------------------------------------------------------
   extern function new(string name="", int has_cover=uvm_ral::NO_COVERAGE);

   extern virtual function void configure(uvm_ral_block parent=null, string hdl_path="");

   /*local*/ extern function void add_block (uvm_ral_block blk);
   /*local*/ extern function void add_reg   (uvm_ral_reg  rg);
   /*local*/ extern function void add_vreg  (uvm_ral_vreg vreg);
   /*local*/ extern function void add_mem   (uvm_ral_mem  mem);

   /*local*/ extern virtual function void Xlock_modelX();
   /*local*/ extern function bit Xis_lockedX();


  //-----------------
  // Group: Hierarchy
  //-----------------


   extern virtual function void set_parent(uvm_ral_block parent);

   //------------------------------------------------------------------------------
   // FUNCTION: get_parent
   // Returns a reference to the descriptor of the system that includes the block or system
   // corresponding to the descriptor instance. If this is the top-level block or system,
   // returns null. 
   //------------------------------------------------------------------------------
   extern virtual function uvm_ral_block get_parent();

   extern virtual function string get_full_name();

   extern static  function void get_root_blocks(ref uvm_ral_block blks[$]);
   extern virtual function void get_blocks           (ref uvm_ral_block  blks[$],   input bit hier=1);

   //------------------------------------------------------------------------------
   // FUNCTION: get_registers
   // Fills the specified dynamic array with the descriptor for all of the registers contained
   // in the block or system. If a domain is specified, only the registers accessible by the
   // specified domain are returned. The order in which the registers are located in the array
   // is not specified. 
   //------------------------------------------------------------------------------
   extern virtual function void get_registers        (ref uvm_ral_reg    regs[$],   input bit hier=1);

   //------------------------------------------------------------------------------
   // FUNCTION: get_memories
   // Fills the specified dynamic array with the descriptor for all of the memories contained
   // in the block or system. If a domain is specified, only those memories accessible in the
   // specified domain are returned. The order in which the memories are located in the array
   // is not specified. 
   //------------------------------------------------------------------------------
   extern virtual function void get_memories         (ref uvm_ral_mem    mems[$],   input bit hier=1);

   //------------------------------------------------------------------------------
   // FUNCTION: get_fields
   // Fills the specified dynamic array with the descriptor for all of the fields contained
   // in the block or system. If a domain is specified, only the fields accessible through
   // the specified domain are returned. The order in which the fields are located in the array
   // is not specified. 
   //------------------------------------------------------------------------------
   extern virtual function void get_fields           (ref uvm_ral_field  fields[$], input bit hier=1);

   //------------------------------------------------------------------------------
   // FUNCTION: get_virtual_registers
   // Fills the specified dynamic array with the descriptor for all of the virtual registers
   // contained in the block or system. If a domain is specified, only the registers implemented
   // in memories accessible by the specified domain are returned. The order in which the
   // registers are located in the array is not specified. 
   //------------------------------------------------------------------------------
   extern virtual function void get_virtual_registers(ref uvm_ral_vreg   regs[$],   input bit hier=1);

   //------------------------------------------------------------------------------
   // FUNCTION: get_virtual_fields
   // Fills the specified dynamic array with the descriptor for all of the virtual fields
   // contained in the block or system. If a domain is specified, only the fields implemented
   // in memories accessible through the specified domain are returned. The order in which
   // the fields are located in the array is not specified. 
   //------------------------------------------------------------------------------
   extern virtual function void get_virtual_fields   (ref uvm_ral_vfield fields[$], input bit hier=1);
   extern virtual function void get_maps             (ref uvm_ral_map    maps[$],   input bit hier=1);


  //-------------------
  // Group: Get By Name
  //-------------------

   extern virtual function uvm_ral_block  get_block_by_name  (string name);  
   extern virtual function uvm_ral_reg    get_reg_by_name    (string name);
   extern virtual function uvm_ral_vreg   get_vreg_by_name   (string name);

   //------------------------------------------------------------------------------
   // FUNCTION: get_mem_by_name
   // Finds a memory with the specified name in the block or system and returns its descriptor.
   // If no memories are found, returns null. Memory name uniqueness is guaranteed only within
   // blocks. Therefore, if used on a system with more than one memory having the same name,
   // this method returns the first memory found. 
   //------------------------------------------------------------------------------
   extern virtual function uvm_ral_mem    get_mem_by_name    (string name);

   //------------------------------------------------------------------------------
   // FUNCTION: get_field_by_name
   // Finds a field with the specified name in the block or system and returns its descriptor.
   // If no fields are found, returns null. Field name uniqueness is guaranteed only within
   // registers. Therefore, if used on a system or block with more than one field having the
   // same name, this method returns the first field found. 
   //------------------------------------------------------------------------------
   extern virtual function uvm_ral_field  get_field_by_name  (string name);
   extern virtual function uvm_ral_vfield get_vfield_by_name (string name);
   extern virtual function uvm_ral_map    get_map_by_name    (string name);


  //-------------------
  // Group: Address Map
  //-------------------

   extern virtual function uvm_ral_map create_map      (string name,
                                                        uvm_ral_addr_t base_addr,
                                                        int unsigned n_bytes,
                                                        uvm_ral::endianness_e endian);
   extern virtual function void        add_map         (uvm_ral_map map);
   extern function void                set_default_map (uvm_ral_map map);
   extern function uvm_ral_map         get_default_map ();


   //--------------------------------
   // Group: Attributes & Constraints
   //--------------------------------


   //------------------------------------------------------------------------------
   // FUNCTION: get_constraints
   // Fills the specified dynamic array with the names of the constraint blocks in this block
   // or system. Does not include the constraint blocks in the registers or fields in this
   // block or system. The location of each constraint block name in the array is not defined.
   // 
   //------------------------------------------------------------------------------
   extern virtual function void get_constraints(ref string names[$]);


   //------------------------------------------------------------------------------
   // FUNCTION: set_attribute
   // Set the specified attribute to the specified value for this block or system. If the value
   // is specified as "", the specified attribute is deleted. A warning is issued if an existing
   // attribute is modified. Attribute names are case sensitive. 
   //------------------------------------------------------------------------------
   extern virtual function void set_attribute(string name,
                                              string value);

   //------------------------------------------------------------------------------
   // FUNCTION: get_attribute
   // Get the value of the specified attribute for this block or system. If the attribute does
   // not exists, "" is returned. If the "inherited" argument is specifed as TRUE, the value
   // of the attribute is inherited from the nearest enclosing system if it is not specified
   // for this block or system. If it is specified as FALSE, the value "" is returned if it does
   // not exists in the this block or system. Attribute names are case sensitive. 
   //------------------------------------------------------------------------------
   extern virtual function string get_attribute(string name,
                                                bit inherited = 1);
   extern virtual function void get_attributes(ref string names[string],
                                                   input bit inherited = 1);

   
   /*local*/ extern function void Xadd_constraintsX(string name);


   //----------------
   // Group: Coverage
   //----------------

   extern virtual function bit can_cover(int models);

   //------------------------------------------------------------------------------
   // FUNCTION: set_cover
   // Turns the collection of functional coverage measurements on or off for this block or
   // system and all subsystems, blocks, registers, fields and memories within it. The functional
   // coverage measurement is turned on for every coverage model specified. Multiple functional
   // coverage models can be specified by adding the functional coverage model identifiers.
   // All other functional coverage models are turned off. Returns the sum of all functional
   // coverage models whose measurements were previously on. This method can only control
   // the measurement of functional coverage models that have been generated by ralgen (see
   // "Predefined Functional Coverage Models" on page 121) then enabled when calling "uvm_ral_block::new()"
   // or "uvm_ral_sys::new()". See the "uvm_ral_block::has_cover()" method to identify
   // the available functional coverage models. 
   //------------------------------------------------------------------------------
   extern virtual function int set_cover(int is_on);

   //------------------------------------------------------------------------------
   // FUNCTION: is_cover_on
   // Returns TRUE of measurement for all of the specified functional coverage models that
   // are currently on. Multiple functional coverage models can be specified by adding the
   // functional coverage model identifiers. See "uvm_ral_block::set_cover()" for more
   // details. 
   //------------------------------------------------------------------------------
   extern virtual function bit is_cover_on(int is_on = uvm_ral::ALL_COVERAGE);

   /*local*/ extern virtual function void XsampleX(uvm_ral_addr_t  addr,
                                                   uvm_ral_map  map);
   protected virtual function void     map_coverage    (uvm_ral_map map);
   endfunction


   //--------------
   // Group: Access
   //--------------

   extern virtual function uvm_ral::path_e get_default_path();


   //------------------------------------------------------------------------------
   // FUNCTION: reset
   // Sets the mirror value of all registers in the block or system to the specified hard or
   // soft reset value. Does not actually set the value of the registers in the design, only
   // the values mirrored in their corresponding descriptor in the RAL model. If a domain
   // is specified, only those registers accessible through the specified domain are reset.
   // The mirror values of memories is not modified. 
   //------------------------------------------------------------------------------
   extern virtual function void reset(uvm_ral::reset_e kind = uvm_ral::HARD); 


   //------------------------------------------------------------------------------
   // FUNCTION: needs_update
   // If a mirror value has been modified in the RAL model without actually updating the actual
   // register, the mirror and state of the registers are outdated. This method returns TRUE
   // if the state of the registers needs to be updated to match the mirrored values (or vice-versa).
   // The mirror values, or actual content of registers, are not modified. For additional
   // information, see "uvm_ral_block::update()" or "uvm_ral_block::mirror()". 
   //------------------------------------------------------------------------------
   extern virtual function bit needs_update();


   //------------------------------------------------------------------------------
   // TASK: update
   // Using the minimum number of write operations, updates the content of the registers
   // in the design to match the mirrored values. The update can be performed using the physical
   // interfaces (front-door access) or back-door (zero-time) access. This method performs
   // the reverse operation of "uvm_ral_block::mirror()". 
   //------------------------------------------------------------------------------
   extern virtual task update(output uvm_ral::status_e  status,
                              input  uvm_ral::path_e    path = uvm_ral::DEFAULT,
                              input  uvm_sequence_base  parent = null,
                              input  int                prior = -1,
                              input  uvm_object         extension = null,
                              input  string             fname = "",
                              input  int                lineno = 0);


   //------------------------------------------------------------------------------
   // TASK: mirror
   // Updates the content of the registers mirror values to match their corresponding values
   // in the design. The mirroring can be performed using the physical interfaces (front-door
   // access) or back-door (zero-time) access. If the check argument is specified as uvm_ral::VERB,
   // an error message is issued if the current mirrored value does not match the actual value
   // in the design. This method performs the reverse operation of "uvm_ral_block::update()".
   // 
   //------------------------------------------------------------------------------
   extern virtual task mirror(output uvm_ral::status_e  status,
                              input  uvm_ral::check_e   check = uvm_ral::NO_CHECK,
                              input  uvm_ral::path_e    path  = uvm_ral::DEFAULT,
                              input  uvm_sequence_base  parent = null,
                              input  int                prior = -1,
                              input  uvm_object         extension = null,
                              input  string             fname = "",
                              input  int                lineno = 0);
   
   extern virtual task write_reg_by_name(
                              output uvm_ral::status_e   status,
                              input  string              name,
                              input  uvm_ral_data_t      data,
                              input  uvm_ral::path_e     path = uvm_ral::DEFAULT,
                              input  uvm_ral_map         map = null,
                              input  uvm_sequence_base   parent = null,
                              input  int                 prior = -1,
                              input  uvm_object          extension = null,
                              input  string              fname = "",
                              input  int                 lineno = 0);

   extern virtual task read_reg_by_name(
                              output uvm_ral::status_e  status,
                              input  string             name,
                              output uvm_ral_data_t     data,
                              input  uvm_ral::path_e    path = uvm_ral::DEFAULT,
                              input  uvm_ral_map        map = null,
                              input  uvm_sequence_base  parent = null,
                              input  int                prior = -1,
                              input  uvm_object         extension = null,
                              input  string             fname = "",
                              input  int                lineno = 0);

   extern virtual task write_mem_by_name(
                              output uvm_ral::status_e  status,
                              input  string             name,
                              input  uvm_ral_addr_t     offset,
                              input  uvm_ral_data_t     data,
                              input  uvm_ral::path_e    path = uvm_ral::DEFAULT,
                              input  uvm_ral_map        map = null,
                              input  uvm_sequence_base  parent = null,
                              input  int                prior = -1,
                              input  uvm_object         extension = null,
                              input  string             fname = "",
                              input  int                lineno = 0);

   extern virtual task read_mem_by_name(
                              output uvm_ral::status_e  status,
                              input  string             name,
                              input  uvm_ral_addr_t     offset,
                              output uvm_ral_data_t     data,
                              input  uvm_ral::path_e    path = uvm_ral::DEFAULT,
                              input  uvm_ral_map        map = null,
                              input  uvm_sequence_base  parent = null,
                              input  int                prior = -1,
                              input  uvm_object         extension = null,
                              input  string             fname = "",
                              input  int                lineno = 0);


   //------------------------------------------------------------------------------
   // TASK: readmemh
   // Not yet implemented. Initializes the content of all registers and memories in the design
   // using the values in the specified file. The values are updated using the default access
   // path. See "uvm_ral_block::writememh()" for details. The format of the file is not
   // specified. 
   //------------------------------------------------------------------------------
   extern virtual task readmemh(string filename);

   //------------------------------------------------------------------------------
   // TASK: writememh
   // Not yet implemented. Dumps the content of all registers and memories in the design to
   // the specified file. The file can then be used as an input for the "uvm_ral_block::readmemh()"
   // method. The values are obtained using the default access path. The format of the file
   // is not specified. 
   //------------------------------------------------------------------------------
   extern virtual task writememh(string filename);


   //------------------------------------------------------------------------------
   // FUNCTION: ral_power_down
   // Specify that this block or all blocks in this system has been put in a power-saving state.
   // A read or write access to any register or memory inside the powered-down block will result
   // in a run-time error message and a uvm_ral::ERROR status code. If the "retain" argument
   // is TRUE, the mirrored value of registers with an inherited non-zero RETAIN attribute
   // value will be maintained and restored when the block is powered back up using the uvm_ral_block::ral_power_up()
   // method. If the retain argument is FALSE, the mirrored value of registers will be set
   // to the reset value when the block or system is powered back up. A powered-down block with
   // retention enabled can be further powered down with retention disabled. This method
   // does not physically power down the block or system. It only indicates to the RAL model
   // that the block or system has been powered down. 
   //------------------------------------------------------------------------------
   extern virtual function void ral_power_down(bit retain = 0);

   //------------------------------------------------------------------------------
   // FUNCTION: ral_power_up
   // Specify that the block or blocks in the system and the memories within them with an inherited
   // POWER_DOMAIN attribute value that matches the specified power domain regular expression
   // have been restored to a powered-up state. If the power domain is specified as "", then
   // the block or blocks in the system and any memory within them are powered up regardless
   // of the POWER_DOMAIN attribute value. If a block was as powered down using the uvm_ral_block::ral_power_down()
   // method with a "retain" argument specified as TRUE, the mirrored value of registers
   // with an inherited non-zero RETAIN attribute value is restored. Otherwise, the mirrored
   // value of registers is set to the specified reset value. By default, a block or system
   // is powered-up. This method does not physically power up the block or system. It only
   // indicates to the RAL model that the block or system has been powered up. 
   //------------------------------------------------------------------------------
   extern virtual function void ral_power_up(string power_maps = "");

   //----------------
   // Group: Backdoor
   //----------------

   extern function uvm_ral_reg_backdoor get_backdoor(bit inherit = 1);

   extern function void set_backdoor        (uvm_ral_reg_backdoor bkdr,
                                             string fname = "",
                                             int lineno = 0);

   extern function void clear_hdl_path      (string kind = "RTL");
   extern function void add_hdl_path        (string path, string kind = "RTL");
   extern function bit  has_hdl_path        (string kind = "");
   extern function void get_hdl_path        (ref string paths[$], input string kind = "");
   extern function void get_full_hdl_path   (ref string paths[$], input string kind = "");

   extern function bit    set_default_hdl_path (string kind);
   extern function string get_default_hdl_path ();
   extern function void   set_hdl_path_root    (string path, string kind = "RTL");
   extern function bit    is_hdl_path_root     (string kind = "");

   //-----------------
   // Group: Basic Ops
   //-----------------

   extern virtual function void   do_print      (uvm_printer printer);
   extern virtual function void   do_copy       (uvm_object rhs);
   extern virtual function bit    do_compare    (uvm_object  rhs,
                                                 uvm_comparer comparer);
   extern virtual function void   do_pack       (uvm_packer packer);
   extern virtual function void   do_unpack     (uvm_packer packer);
   extern virtual function string convert2string ();
   extern virtual function uvm_object clone();
   
   extern local function void Xinit_address_mapsX();

endclass: uvm_ral_block

//------------------------------------------------------------------------------


//---------------
// Initialization
//---------------

// new

function uvm_ral_block::new(string name="", int has_cover=uvm_ral::NO_COVERAGE);
   super.new(name);
   hdl_paths_pool = new("hdl_paths");
   this.has_cover = has_cover;
   // Root block until registered with a parent
   m_roots[this] = 1;
endfunction: new


// configure

function void uvm_ral_block::configure(uvm_ral_block parent=null, string hdl_path="");
  this.parent = parent; 
  if (parent != null)
    this.parent.add_block(this);
  if (hdl_path != "")
    add_hdl_path(hdl_path);
endfunction


// add_block

function void uvm_ral_block::add_block (uvm_ral_block blk);
   if (this.Xis_lockedX()) begin
      `uvm_error("RAL", "Cannot add subblock to locked block model");
      return;
   end
   if (this.blks.exists(blk)) begin
      `uvm_error("RAL", {"Subblock '",blk.get_name(),
         "' has already been registered with block '",get_name(),"'"})
       return;
   end
   blks[blk] = id++;
   if (m_roots.exists(blk)) m_roots.delete(blk);
endfunction


// add_reg

function void uvm_ral_block::add_reg(uvm_ral_reg rg);
   if (this.Xis_lockedX()) begin
      `uvm_error("RAL", "Cannot add register to locked block model");
      return;
   end

   if (this.regs.exists(rg)) begin
      `uvm_error("RAL", {"Register '",rg.get_name(),
         "' has already been registered with block '",get_name(),"'"})
       return;
   end

   regs[rg] = id++;
endfunction: add_reg


// add_vreg

function void uvm_ral_block::add_vreg(uvm_ral_vreg vreg);
   if (this.Xis_lockedX()) begin
      `uvm_error("RAL", "Cannot add virtual register to locked block model");
      return;
   end

   if (this.vregs.exists(vreg)) begin
      `uvm_error("RAL", {"Virtual register '",vreg.get_name(),
         "' has already been registered with block '",get_name(),"'"})
       return;
   end
   vregs[vreg] = id++;
endfunction: add_vreg


// add_mem

function void uvm_ral_block::add_mem(uvm_ral_mem mem);
   if (this.Xis_lockedX()) begin
      `uvm_error("RAL", "Cannot add memory to locked block model");
      return;
   end

   if (this.mems.exists(mem)) begin
      `uvm_error("RAL", {"Memory '",mem.get_name(),
         "' has already been registered with block '",get_name(),"'"})
       return;
   end
   mems[mem] = id++;
endfunction: add_mem


// set_parent

function void uvm_ral_block::set_parent(uvm_ral_block parent);
  if (this != parent)
    this.parent = parent;
endfunction


// Xis_lockedX

function bit uvm_ral_block::Xis_lockedX();
   Xis_lockedX = this.locked;
endfunction: Xis_lockedX


// Xlock_modelX

function void uvm_ral_block::Xlock_modelX();

   if (Xis_lockedX())
     return;

   locked = 1;

   foreach (regs[rg])
     rg.Xlock_modelX();

   foreach (mems[mem])
     mem.Xlock_modelX();

   foreach (blks[blk])
     blk.Xlock_modelX();

   //`ifndef UVM_RAL_FAST_SRCH
   if (this.parent == null)
      Xinit_address_mapsX();
   //`endif

   //if (this.parent == null)
   //   foreach (maps[map])
   //     map.Xcheck_overlapX();

endfunction: Xlock_modelX



//--------------------------
// Get Hierarchical Elements
//--------------------------

function string uvm_ral_block::get_full_name();
   uvm_ral_block blk;

   get_full_name = this.get_name();

   // Do not include top-level name in full name
   blk = this.get_parent();

   if (blk == null)
     return get_full_name;

   if (blk.get_parent() == null)
     return get_full_name;

   get_full_name = {this.parent.get_full_name(), ".", get_full_name};

endfunction: get_full_name


// get_fields

function void uvm_ral_block::get_fields(ref uvm_ral_field fields[$],
                                        input bit hier=1);

   foreach (this.regs[rg])
     rg.get_fields(fields);
   
   if (hier)
     foreach (this.blks[blk])
       blk.get_fields(fields);

endfunction: get_fields


// get_virtual_fields

function void uvm_ral_block::get_virtual_fields(ref uvm_ral_vfield fields[$],
                                                input bit hier=1);

   foreach (this.vregs[vreg])
     vreg.get_fields(fields);
   
   if (hier)
     foreach (this.blks[blk])
       blk.get_virtual_fields(fields);

endfunction: get_virtual_fields


// get_registers

function void uvm_ral_block::get_registers(ref uvm_ral_reg regs[$],
                                           input bit hier=1);

   foreach (this.regs[rg])
     regs.push_back(rg);

   if (hier)
     foreach (this.blks[blk])
       blk.get_registers(regs);

endfunction: get_registers


// get_virtual_registers

function void uvm_ral_block::get_virtual_registers(ref uvm_ral_vreg regs[$],
                                                   input bit hier=1);

   foreach (this.vregs[rg])
     regs.push_back(rg);

   if (hier)
     foreach (this.blks[blk])
       blk.get_virtual_registers(regs);

endfunction: get_virtual_registers


// get_memories

function void uvm_ral_block::get_memories(ref uvm_ral_mem mems[$],
                                          input bit hier=1);

   foreach (this.mems[mem])
     mems.push_back(mem);

   if (hier)
     foreach (this.blks[blk])
       blk.get_memories(mems);

endfunction: get_memories


// get_blocks

function void uvm_ral_block::get_blocks(ref uvm_ral_block blks[$],
                                        input bit hier=1);

   foreach (this.blks[blk]) begin
     blks.push_back(blk);
     if (hier)
       blk.get_blocks(blks);
   end

endfunction: get_blocks


// get_root_blocks

function void uvm_ral_block::get_root_blocks(ref uvm_ral_block blks[$]);

   foreach (m_roots[blk]) begin
      blks.push_back(blk);
   end

endfunction: get_root_blocks


// get_maps

function void uvm_ral_block::get_maps(ref uvm_ral_map maps[$],
                                      input bit hier=1);

   foreach (this.maps[map])
     maps.push_back(map);

   if (hier)
     foreach (this.blks[blk])
       blk.get_maps(maps);

endfunction


// get_parent

function uvm_ral_block uvm_ral_block::get_parent();
   get_parent = this.parent;
endfunction: get_parent


//------------
// Get-By-Name
//------------

// get_block_by_name

function uvm_ral_block uvm_ral_block::get_block_by_name(string name);

   if (get_name() == name)
     return this;

   foreach (blks[blk]) begin
     uvm_ral_block tmp_blk;
     if (blk.get_name() == name)
       return blk;
     tmp_blk = blk.get_block_by_name(name);
     if (tmp_blk != null)
       return tmp_blk;
   end

   `uvm_warning("RAL", {"Unable to locate block '",name,
                "' in block '",get_full_name(),"'"})
   return null;

endfunction: get_block_by_name


// get_reg_by_name

function uvm_ral_reg uvm_ral_block::get_reg_by_name(string name);

   foreach (regs[rg])
     if (rg.get_name() == name)
       return rg;

   foreach (blks[blk]) begin
     uvm_ral_reg rg;
     rg = blk.get_reg_by_name(name);
     if (rg != null)
       return rg;
   end

   `uvm_warning("RAL", {"Unable to locate register '",name,
                "' in block '",get_full_name(),"'"})
   return null;

endfunction: get_reg_by_name


// get_vreg_by_name

function uvm_ral_vreg uvm_ral_block::get_vreg_by_name(string name);

   foreach (vregs[rg])
     if (rg.get_name() == name)
       return rg;

   foreach (blks[blk]) begin
     uvm_ral_vreg rg;
     rg = blk.get_vreg_by_name(name);
     if (rg != null)
       return rg;
   end

   `uvm_warning("RAL", {"Unable to locate virtual register '",name,
                "' in block '",get_full_name(),"'"})
   return null;

endfunction: get_vreg_by_name


// get_mem_by_name

function uvm_ral_mem uvm_ral_block::get_mem_by_name(string name);

   foreach (mems[mem])
     if (mem.get_name() == name)
       return mem;

   foreach (blks[blk]) begin
     uvm_ral_mem mem;
     mem = blk.get_mem_by_name(name);
     if (mem != null)
       return mem;
   end

   `uvm_warning("RAL", {"Unable to locate memory '",name,
                "' in block '",get_full_name(),"'"})
   return null;

endfunction: get_mem_by_name


// get_field_by_name

function uvm_ral_field uvm_ral_block::get_field_by_name(string name);

   foreach (regs[rg]) begin
      uvm_ral_field fields[$];
      rg.get_fields(fields);
      foreach (fields[i])
        if (fields[i].get_name() == name)
          return fields[i];
   end

   foreach (blks[blk]) begin
     uvm_ral_field field;
     field = blk.get_field_by_name(name);
     if (field != null)
       return field;
   end

   `uvm_warning("RAL", {"Unable to locate field '",name,
                "' in block '",get_full_name(),"'"})

   return null;

endfunction: get_field_by_name


// get_vfield_by_name

function uvm_ral_vfield uvm_ral_block::get_vfield_by_name(string name);

   foreach (vregs[rg]) begin
      uvm_ral_vfield fields[$];
      rg.get_fields(fields);
      foreach (fields[i])
        if (fields[i].get_name() == name)
          return fields[i];
   end

   foreach (blks[blk]) begin
     uvm_ral_vfield field;
     field = blk.get_vfield_by_name(name);
     if (field != null)
       return field;
   end

   `uvm_warning("RAL", {"Unable to locate virtual field '",name,
                "' in block '",get_full_name(),"'"})

   return null;

endfunction: get_vfield_by_name



//-------------
// Coverage API
//-------------

// set_cover

function int uvm_ral_block::set_cover(int is_on);
   int can_cvr;

   if (is_on == uvm_ral::NO_COVERAGE) begin
      this.cover_on = is_on;
      return this.cover_on;
   end

   if ((this.has_cover & is_on) == 0) begin
      `uvm_warning("RAL", {this.get_full_name()," - Cannot turn ON any ",
          "coverage becasue the corresponding coverage model was not generated."})
      return this.cover_on;
   end

   if (is_on & uvm_ral::REG_BITS) begin
      if (this.has_cover & uvm_ral::REG_BITS) begin
          this.cover_on |= uvm_ral::REG_BITS;
      end
      else begin
        `uvm_warning("RAL", {this.get_full_name()," - Cannot turn ON Register Bit ",
            "coverage becasue the corresponding coverage model was not generated."})
      end
   end

   if (is_on & uvm_ral::FIELD_VALS) begin
      if (this.has_cover & uvm_ral::FIELD_VALS) begin
          this.cover_on |= uvm_ral::FIELD_VALS;
      end
      else begin
        `uvm_warning("RAL", {this.get_full_name()," - Cannot turn ON Field Value ",
            "coverage becasue the corresponding coverage model was not generated."})
      end
   end

   if (is_on & uvm_ral::ADDR_MAP) begin
      if (this.has_cover & uvm_ral::ADDR_MAP) begin
          this.cover_on |= uvm_ral::ADDR_MAP;
      end 
      else begin
        `uvm_warning("RAL", {this.get_full_name()," - Cannot turn ON Address Map ",
            "coverage becasue the corresponding coverage model was not generated."})
      end
   end

   set_cover = this.cover_on;

   can_cvr = is_on & set_cover; 

   if (can_cvr == 0)
     return set_cover;

   foreach (regs[rg])
     rg.set_cover(can_cvr);

   foreach (mems[mem])
     mem.set_cover(can_cvr);

   foreach (blks[blk])
     blk.set_cover(can_cvr);

endfunction: set_cover


// sample

function void uvm_ral_block::XsampleX(uvm_ral_addr_t addr,
                                    uvm_ral_map map);
   // Nothing to do in this base class
endfunction


// can_cover

function bit uvm_ral_block::can_cover(int models);
   return ((this.has_cover & models) == models);
endfunction: can_cover


// is_cover_on

function bit uvm_ral_block::is_cover_on(int is_on = uvm_ral::ALL_COVERAGE);
   if (this.can_cover(is_on) == 0) return 0;
   return ((this.cover_on & is_on) == is_on);
endfunction: is_cover_on


// ral_power_done

function void uvm_ral_block::ral_power_down(bit retain = 0);
endfunction: ral_power_down


// ral_power_up

function void uvm_ral_block::ral_power_up(string power_maps = "");
endfunction: ral_power_up



//-------------------------
// Attributes & Constraints
//-------------------------

// set_attribute

function void uvm_ral_block::set_attribute(string name,
                                           string value);
   if (name == "") begin
      `uvm_error("RAL", {"Cannot set anonymous attribute \"\" in block '",
                         get_full_name(),"'"})
      return;
   end

   if (this.attributes.exists(name)) begin
      if (value != "") begin
         `uvm_warning("RAL", {"Redefining attribute '",name,"' in block '",
                         get_full_name(),"' to '",value,"'"})
         this.attributes[name] = value;
      end
      else begin
         this.attributes.delete(name);
      end
      return;
   end

   if (value == "") begin
      `uvm_warning("RAL", {"Attempting to delete non-existent attribute '",
                          name, "' in block '", get_full_name(), "'"})
      return;
   end

   this.attributes[name] = value;

endfunction: set_attribute


// get_attribute

function string uvm_ral_block::get_attribute(string name, bit inherited = 1);

   if (inherited && parent != null)
      get_attribute = parent.get_attribute(name);

   if (get_attribute == "" && this.attributes.exists(name))
      return this.attributes[name];

   return "";
endfunction


// get_attributes

function void uvm_ral_block::get_attributes(ref string names[string],
                                            input bit inherited = 1);
   // attributes at higher levels supercede those at lower levels
   if (inherited && parent != null)
     parent.get_attributes(names,1);

   foreach (attributes[nm])
     if (!names.exists(nm))
       names[nm] = attributes[nm];

endfunction: get_attributes


// Xadd_constraintsX

function void uvm_ral_block::Xadd_constraintsX(string name);

   if (this.locked) begin
      `uvm_error("RAL", "Cannot add constraints to locked model");
      return;
   end

   // Check if the constraint block already exists
   foreach (this.constr[i]) begin
      if (this.constr[i] == name) begin
         `uvm_warning("RAL", $psprintf("Constraint \"%s\" already added",
                                          name));
         return;
      end
   end

   constr.push_back(name);

endfunction: Xadd_constraintsX


// get_constraints

function void uvm_ral_block::get_constraints(ref string names[$]);
  names = constr;
endfunction



//----------------
// Run-Time Access
//----------------


// reset

function void uvm_ral_block::reset(uvm_ral::reset_e kind = uvm_ral::HARD);

   foreach (regs[rg])
     rg.reset(kind);

   foreach (blks[blk])
     blk.reset(kind);

endfunction


// needs_update

function bit uvm_ral_block::needs_update();
   needs_update = 0;

   foreach (regs[rg])
     if (rg.needs_update())
       return 1;

   foreach (blks[blk])
     if (blk.needs_update())
       return 1;
endfunction: needs_update


// update

task uvm_ral_block::update(output uvm_ral::status_e  status,
                           input  uvm_ral::path_e    path = uvm_ral::DEFAULT,
                           input  uvm_sequence_base  parent = null,
                           input  int                prior = -1,
                           input  uvm_object         extension = null,
                           input  string             fname = "",
                           input  int                lineno = 0);
   status = uvm_ral::IS_OK;

   if (!needs_update()) begin
     `uvm_info("RAL", $sformatf("%s:%0d - RAL block %s does not need updating",
                    fname, lineno, this.get_name()), UVM_HIGH);

   end
   
   `uvm_info("RAL", $sformatf("%s:%0d - Updating ral block %s with %s path",
                    fname, lineno, this.get_name(), path.name ), UVM_HIGH);

   foreach (this.regs[rg]) begin
      if (rg.needs_update()) begin
         rg.update(status, path, null, parent, prior, extension);
         if (status != uvm_ral::IS_OK || status != uvm_ral::HAS_X) begin;
           `uvm_error("RAL", $sformatf("Register \"%s\" could not be updated",
                                        rg.get_full_name()));
           return;
         end
      end
   end

   foreach (blks[blk])
     blk.update(status,path,parent,prior,extension,fname,lineno);

endtask: update


// mirror

task uvm_ral_block::mirror(output uvm_ral::status_e  status,
                           input  uvm_ral::check_e   check = uvm_ral::NO_CHECK,
                           input  uvm_ral::path_e    path = uvm_ral::DEFAULT,
                           input  uvm_sequence_base  parent = null,
                           input  int                prior = -1,
                           input  uvm_object         extension = null,
                           input  string             fname = "",
                           input  int                lineno = 0);
   status = uvm_ral::IS_OK;

   if (!needs_update()) begin
     `uvm_info("RAL", $sformatf("%s:%0d - RAL block %s does not need updating",
                    fname, lineno, this.get_name()), UVM_HIGH);

   end
   
   `uvm_info("RAL", $sformatf("%s:%0d - Updating ral block %s with %s path",
                    fname, lineno, this.get_name(), path.name ), UVM_HIGH);

   foreach (this.regs[rg]) begin
      if (rg.needs_update())  begin
         rg.update(status, path, null, parent, prior, extension);
         if (status != uvm_ral::IS_OK || status != uvm_ral::HAS_X) begin;
           `uvm_error("RAL", $sformatf("Register \"%s\" could not be updated",
                                        rg.get_full_name()));
           return;
         end
      end
   end

   foreach (blks[blk])
     blk.update(status,path,parent,prior,extension,fname,lineno);

endtask: mirror


// write_reg_by_name

task uvm_ral_block::write_reg_by_name(output uvm_ral::status_e   status,
                                      input  string              name,
                                      input  uvm_ral_data_t      data,
                                      input  uvm_ral::path_e     path = uvm_ral::DEFAULT,
                                      input  uvm_ral_map      map = null,
                                      input  uvm_sequence_base   parent = null,
                                      input  int                 prior = -1,
                                      input  uvm_object          extension = null,
                                      input  string              fname = "",
                                      input  int                 lineno = 0);
   uvm_ral_reg rg;
   this.fname = fname;
   this.lineno = lineno;

   status = uvm_ral::ERROR;
   rg = this.get_reg_by_name(name);
   if (rg != null)
     rg.write(status, data, path, map, parent, prior, extension);

endtask: write_reg_by_name


// read_reg_by_name

task uvm_ral_block::read_reg_by_name(output uvm_ral::status_e  status,
                                     input  string             name,
                                     output uvm_ral_data_t     data,
                                     input  uvm_ral::path_e    path = uvm_ral::DEFAULT,
                                     input  uvm_ral_map     map = null,
                                     input  uvm_sequence_base  parent = null,
                                     input  int                prior = -1,
                                     input  uvm_object         extension = null,
                                     input  string             fname = "",
                                     input  int                lineno = 0);
   uvm_ral_reg rg;
   this.fname = fname;
   this.lineno = lineno;

   status = uvm_ral::ERROR;
   rg = this.get_reg_by_name(name);
   if (rg != null)
     rg.read(status, data, path, map, parent, prior, extension);
endtask: read_reg_by_name


// write_mem_by_name

task uvm_ral_block::write_mem_by_name(output uvm_ral::status_e  status,
                                          input  string             name,
                                          input  uvm_ral_addr_t     offset,
                                          input  uvm_ral_data_t     data,
                                          input  uvm_ral::path_e    path = uvm_ral::DEFAULT,
                                          input  uvm_ral_map     map = null,
                                          input  uvm_sequence_base  parent = null,
                                          input  int                prior = -1,
                                          input  uvm_object         extension = null,
                                          input  string             fname = "",
                                          input  int                lineno = 0);
   uvm_ral_mem mem;
   this.fname = fname;
   this.lineno = lineno;

   status = uvm_ral::ERROR;
   mem = get_mem_by_name(name);
   if (mem != null)
     mem.write(status, offset, data, path, map, parent, prior, extension);
endtask: write_mem_by_name


// read_mem_by_name

task uvm_ral_block::read_mem_by_name(output uvm_ral::status_e  status,
                                         input  string             name,
                                         input  uvm_ral_addr_t     offset,
                                         output uvm_ral_data_t     data,
                                         input  uvm_ral::path_e    path = uvm_ral::DEFAULT,
                                         input  uvm_ral_map     map = null,
                                         input  uvm_sequence_base  parent = null,
                                         input  int                prior = -1,
                                         input  uvm_object         extension = null,
                                         input  string             fname = "",
                                         input  int                lineno = 0);
   uvm_ral_mem mem;
   this.fname = fname;
   this.lineno = lineno;

   status = uvm_ral::ERROR;
   mem = get_mem_by_name(name);
   if (mem != null)
     mem.read(status, offset, data, path, map, parent, prior, extension);
endtask: read_mem_by_name


// readmemh

task uvm_ral_block::readmemh(string filename);
   // TODO
endtask: readmemh


// writememh

task uvm_ral_block::writememh(string filename);
   // TODO
endtask: writememh


//---------------
// Map Management
//---------------

// create_map

function uvm_ral_map uvm_ral_block::create_map(string name, uvm_ral_addr_t base_addr, int unsigned n_bytes, uvm_ral::endianness_e endian);

   //example: APB = create_map("APB", 1, uvm_ral::LITTLE_ENDIAN);
   uvm_ral_map  map;

   if (this.locked) begin
      `uvm_error("RAL", "Cannot add map to locked model");
      return null;
   end

   map = uvm_ral_map::type_id::create(name,,this.get_full_name());
   map.configure(this,base_addr,n_bytes,endian);

   this.maps[map] = 1;
   if (maps.num() == 1)
     default_map = map;
   this.map_coverage(map);

   return map;
endfunction


// add_map

function void uvm_ral_block::add_map(uvm_ral_map map);

   if (this.locked) begin
      `uvm_error("RAL", "Cannot add map to locked model");
      return;
   end

   if (this.maps.exists(map)) begin
      `uvm_error("RAL", {"Map '",map.get_name(),
                 "' already exists in '",get_full_name(),"'"})
      return;
   end

   this.maps[map] = 1;
   if (maps.num() == 1)
     default_map = map;
   this.map_coverage(map);

endfunction: add_map


// get_map_by_name

function uvm_ral_map uvm_ral_block::get_map_by_name(string name);
   uvm_ral_map maps[$];

   this.get_maps(maps,1);

   foreach (maps[i])
     if (maps[i].get_name() == name)
       return maps[i];

   `uvm_warning("RAL", {"Map with name '",name,"' does not exist in block"})
   return null;
endfunction


// set_default_map

function void uvm_ral_block::set_default_map(uvm_ral_map map);
  if (!maps.exists(map))
   `uvm_warning("RAL", {"Map '",map.get_full_name(),"' does not exist in block"})
  default_map = map;
endfunction


// get_default_map

function uvm_ral_map uvm_ral_block::get_default_map();
  return default_map;
endfunction


// get_default_path

function uvm_ral::path_e uvm_ral_block::get_default_path();

   if (this.default_path != uvm_ral::DEFAULT)
      return this.default_path;

   if (this.parent != null)
      return this.parent.get_default_path();

   return uvm_ral::BFM;

endfunction


// Xinit_address_mapsX

function void uvm_ral_block::Xinit_address_mapsX();
   foreach (this.maps[map]) begin
      map.Xinit_address_mapX();
   end
      //map.Xverify_map_configX();
endfunction


//----------------
// Group- Backdoor
//----------------

// set_backdoor

function void uvm_ral_block::set_backdoor(uvm_ral_reg_backdoor bkdr,
                                          string               fname = "",
                                          int                  lineno = 0);
   bkdr.fname = fname;
   bkdr.lineno = lineno;
   if (this.backdoor != null &&
       this.backdoor.has_update_threads()) begin
      `uvm_warning("RAL", "Previous register backdoor still has update threads running. Backdoors with active mirroring should only be set before simulation starts.");
   end
   this.backdoor = bkdr;
endfunction: set_backdoor


// get_backdoor

function uvm_ral_reg_backdoor uvm_ral_block::get_backdoor(bit inherit = 1);
   if (backdoor == null && inherit) begin
     uvm_ral_block blk = get_parent();
     while (blk != null) begin
       uvm_ral_reg_backdoor bkdr = blk.get_backdoor();
       if (bkdr != null)
         return bkdr;
       blk = blk.get_parent();
     end
   end
   return this.backdoor;
endfunction: get_backdoor



// clear_hdl_path

function void uvm_ral_block::clear_hdl_path(string kind = "RTL");

  if (kind == "ALL") begin
    hdl_paths_pool = new("hdl_paths");
    return;
  end

  if (kind == "")
    kind = get_default_hdl_path();

  if (!hdl_paths_pool.exists(kind)) begin
    `uvm_warning("RAL",{"Unknown HDL Abstraction '",kind,"'"})
    return;
  end

  hdl_paths_pool.delete(kind);
endfunction


// add_hdl_path

function void uvm_ral_block::add_hdl_path(string path, string kind = "RTL");

  uvm_queue #(string) paths;

  paths = hdl_paths_pool.get(kind);

  paths.push_back(path);

endfunction


// has_hdl_path

function bit  uvm_ral_block::has_hdl_path(string kind = "");
  if (kind == "") begin
    kind = get_default_hdl_path();
  end
  return hdl_paths_pool.exists(kind);
endfunction


// get_hdl_path

function void uvm_ral_block::get_hdl_path(ref string paths[$], input string kind = "");

  uvm_queue #(string) hdl_paths;

  if (kind == "")
    kind = get_default_hdl_path();

  if (!has_hdl_path(kind)) begin
    `uvm_error("RAL",{"Block does not have hdl path defined for abstraction '",kind,"'"})
    return;
  end

  hdl_paths = hdl_paths_pool.get(kind);

  for (int i=0; i<hdl_paths.size();i++)
    paths.push_back(hdl_paths.get(i));

endfunction


// get_full_hdl_path

function void uvm_ral_block::get_full_hdl_path(ref string paths[$], input string kind = "");

   if (kind == "")
      kind = get_default_hdl_path();

   paths.delete();
   if (is_hdl_path_root(kind)) begin
      if (root_hdl_paths[kind] != "")
         paths.push_back(root_hdl_paths[kind]);
      return;
   end

   if (!has_hdl_path(kind)) begin
      `uvm_error("RAL",{"Block does not have hdl path defined for abstraction '",kind,"'"})
      return;
   end
   
   begin
      uvm_queue #(string) hdl_paths = hdl_paths_pool.get(kind);
      string parent_paths[$];

      if (parent != null)
         parent.get_full_hdl_path(parent_paths,kind);

      for (int i=0; i<hdl_paths.size();i++) begin
         string hdl_path = hdl_paths.get(i);

         if (parent_paths.size() == 0) begin
            if (hdl_path != "")
               paths.push_back(hdl_path);

            continue;
         end
         
         foreach (parent_paths[j])  begin
            if (hdl_path == "")
               paths.push_back(parent_paths[j]);
            else
               paths.push_back({ parent_paths[j], ".", hdl_path });
         end
      end
   end
  
endfunction


// get_default_hdl_path

function string uvm_ral_block::get_default_hdl_path();
  if (default_hdl_path == "" && parent != null)
    return parent.get_default_hdl_path();
  return default_hdl_path;
endfunction


// set_default_hdl_path

function bit uvm_ral_block::set_default_hdl_path(string kind);

  if (kind == "") begin
    if (parent == null) begin
      `uvm_error("RAL",{"Block has no parent. ",
           "Must specify a valid HDL abstraction (kind)"})
      return 0;
    end
    kind = parent.get_default_hdl_path();
  end

  if (!has_hdl_path(kind)) begin
    `uvm_error("RAL",{"Block does not have hdl path defined for abstraction '",kind,"'"})
    return 0;
  end

  default_hdl_path = kind;
  return 1;

endfunction


// set_hdl_path_root

function void uvm_ral_block::set_hdl_path_root (string path, string kind = "RTL");
  if (kind == "")
    kind = get_default_hdl_path();

  root_hdl_paths[kind] = path;
endfunction


// is_hdl_path_root

function bit  uvm_ral_block::is_hdl_path_root (string kind = "");
  if (kind == "")
    kind = get_default_hdl_path();

  return root_hdl_paths.exists(kind);
endfunction


//----------------------------------
// Group- Basic Object Operations
//----------------------------------

// do_print

function void uvm_ral_block::do_print (uvm_printer printer);
  uvm_ral_block prnt = get_parent();
  super.do_print(printer);
  printer.print_generic("initiator", prnt.get_type_name(), -1, convert2string());
endfunction


// clone

function uvm_object uvm_ral_block::clone();
  `uvm_fatal("RAL","RAL blocks cannot be cloned")
  return null;
endfunction

// do_copy

function void uvm_ral_block::do_copy(uvm_object rhs);
  `uvm_fatal("RAL","RAL blocks cannot be copied")
endfunction


// do_compare

function bit uvm_ral_block::do_compare (uvm_object  rhs,
                                        uvm_comparer comparer);
  `uvm_warning("RAL","RAL blocks cannot be compared")
  return 0;
endfunction


// do_pack

function void uvm_ral_block::do_pack (uvm_packer packer);
  `uvm_warning("RAL","RAL blocks cannot be packed")
endfunction


// do_unpack

function void uvm_ral_block::do_unpack (uvm_packer packer);
  `uvm_warning("RAL","RAL blocks cannot be unpacked")
endfunction


// convert2string

function string uvm_ral_block::convert2string();
   string image;
   string maps[];
   string blk_maps[];
   bit         single_map;
   uvm_ral::endianness_e endian;
   string prefix = "  ";

`ifdef TODO
   single_map = 1;
   if (map == "") begin
      this.get_maps(maps);
      if (maps.size() > 1) single_map = 0;
   end

   if (single_map) begin
      $sformat(image, "%sBlock %s", prefix, this.get_full_name());

      if (map != "")
        $sformat(image, "%s.%s", image, map);

      endian = this.get_endian(map);

      $sformat(image, "%s -- %0d bytes (%s)", image,
               this.get_n_bytes(map), endian.name());

      foreach (blks[i]) begin
         string img;
         img = blks[i].convert2string({prefix, "   "}, blk_maps[i]);
         image = {image, "\n", img};
      end

   end
   else begin
      $sformat(image, "%Block %s", prefix, this.get_full_name());
      foreach (maps[i]) begin
         string img;
         endian = this.get_endian(maps[i]);
         $sformat(img, "%s   Map \"%s\" -- %0d bytes (%s)",
                  prefix, maps[i],
                  this.get_n_bytes(maps[i]), endian.name());
         image = {image, "\n", img};

         this.get_blocks(blks, blk_maps, maps[i]);
         foreach (blks[j]) begin
            img = blks[j].convert2string({prefix, "      "},
                                    blk_maps[j]);
            image = {image, "\n", img};
         end

         this.get_subsys(sys, blk_maps, maps[i]);
         foreach (sys[j]) begin
            img = sys[j].convert2string({prefix, "      "},
                                   blk_maps[j]);
            image = {image, "\n", img};
         end
      end
   end
`endif
   return image;
endfunction: convert2string



